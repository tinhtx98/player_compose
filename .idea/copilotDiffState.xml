<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.TinhTXPlayerApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Base.Theme.TinhTXPlayer&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:supportsPictureInPicture=&quot;true&quot;&#10;            android:configChanges=&quot;screenSize|smallestScreenSize|screenLayout|orientation&quot;&#10;            android:theme=&quot;@style/Base.Theme.TinhTXPlayer&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;            android:name=&quot;.media.playback.PlaybackService&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:foregroundServiceType=&quot;mediaPlayback&quot;&#10;            android:foregroundServiceType=&quot;mediaPlayback&quot;&#10;            tools:ignore=&quot;ForegroundServicePermission&quot; /&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.TinhTXPlayerApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Base.Theme.TinhTXPlayer&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:supportsPictureInPicture=&quot;true&quot;&#10;            android:configChanges=&quot;screenSize|smallestScreenSize|screenLayout|orientation&quot;&#10;            android:theme=&quot;@style/Base.Theme.TinhTXPlayer&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.media.playback.PlaybackService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;mediaPlayback&quot; /&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/kotlin/com/tinhtx/player/common/Constants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/kotlin/com/tinhtx/player/common/Constants.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.common&#10;&#10;object Constants {&#10;    // Database&#10;    const val DATABASE_NAME = &quot;tinhtx_player_database&quot;&#10;    const val DATABASE_VERSION = 1&#10;    &#10;    // Preferences&#10;    const val PREFERENCES_NAME = &quot;tinhtx_player_preferences&quot;&#10;    &#10;    // Media&#10;    const val MEDIA_ROOT_ID = &quot;media_root_id&quot;&#10;    const val NOTIFICATION_CHANNEL_ID = &quot;tinhtx_player_channel&quot;&#10;    const val NOTIFICATION_ID = 1&#10;    &#10;    // Permission&#10;    const val PERMISSION_REQUEST_CODE = 1001&#10;    &#10;    // Playback&#10;    const val SEEK_BAR_UPDATE_INTERVAL = 1000L&#10;    const val DEFAULT_MEDIA_VOLUME = 0.5f&#10;    &#10;    // Cache&#10;    const val CACHE_SIZE = 100 * 1024 * 1024L // 100MB&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/main/kotlin/com/tinhtx/player/common/Extensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/main/kotlin/com/tinhtx/player/common/Extensions.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.common&#10;&#10;import android.content.Context&#10;import android.widget.Toast&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Extension functions for common operations&#10; */&#10;&#10;// Context extensions&#10;fun Context.showToast(message: String, duration: Int = Toast.LENGTH_SHORT) {&#10;    Toast.makeText(this, message, duration).show()&#10;}&#10;&#10;// Long extensions for time formatting&#10;fun Long.formatDuration(): String {&#10;    val minutes = TimeUnit.MILLISECONDS.toMinutes(this)&#10;    val seconds = TimeUnit.MILLISECONDS.toSeconds(this) % 60&#10;    return String.format(&quot;%d:%02d&quot;, minutes, seconds)&#10;}&#10;&#10;// String extensions&#10;fun String.isValidAudioFile(): Boolean {&#10;    val audioExtensions = listOf(&quot;mp3&quot;, &quot;wav&quot;, &quot;flac&quot;, &quot;aac&quot;, &quot;ogg&quot;, &quot;m4a&quot;)&#10;    return audioExtensions.any { this.lowercase().endsWith(&quot;.$it&quot;) }&#10;}&#10;&#10;fun String.isValidVideoFile(): Boolean {&#10;    val videoExtensions = listOf(&quot;mp4&quot;, &quot;avi&quot;, &quot;mkv&quot;, &quot;mov&quot;, &quot;wmv&quot;, &quot;flv&quot;, &quot;webm&quot;)&#10;    return videoExtensions.any { this.lowercase().endsWith(&quot;.$it&quot;) }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/core/src/test/kotlin/com/tinhtx/player/common/ResourceTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/core/src/test/kotlin/com/tinhtx/player/common/ResourceTest.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.common&#10;&#10;import org.junit.Test&#10;import org.junit.Assert.*&#10;&#10;class ResourceTest {&#10;    &#10;    @Test&#10;    fun `Success resource should contain data`() {&#10;        val data = &quot;test data&quot;&#10;        val resource = Resource.Success(data)&#10;        &#10;        assertEquals(data, resource.data)&#10;        assertNull(resource.message)&#10;    }&#10;    &#10;    @Test&#10;    fun `Error resource should contain message`() {&#10;        val message = &quot;error message&quot;&#10;        val resource = Resource.Error&lt;String&gt;(message)&#10;        &#10;        assertEquals(message, resource.message)&#10;        assertNull(resource.data)&#10;    }&#10;    &#10;    @Test&#10;    fun `Loading resource can contain data`() {&#10;        val data = &quot;loading data&quot;&#10;        val resource = Resource.Loading(data)&#10;        &#10;        assertEquals(data, resource.data)&#10;        assertNull(resource.message)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/dao/MediaDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/dao/MediaDao.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.local.database.dao&#10;&#10;import androidx.room.*&#10;import com.tinhtx.player.local.database.entities.MediaEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface MediaDao {&#10;    &#10;    @Query(&quot;SELECT * FROM media_items&quot;)&#10;    fun getAllMediaItems(): Flow&lt;List&lt;MediaEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM media_items WHERE mediaType = 'AUDIO'&quot;)&#10;    fun getAudioItems(): Flow&lt;List&lt;MediaEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM media_items WHERE mediaType = 'VIDEO'&quot;)&#10;    fun getVideoItems(): Flow&lt;List&lt;MediaEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM media_items WHERE id = :id&quot;)&#10;    fun getMediaItemById(id: String): Flow&lt;MediaEntity?&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM media_items WHERE title LIKE '%' || :query || '%' OR artist LIKE '%' || :query || '%' OR album LIKE '%' || :query || '%'&quot;)&#10;    fun searchMediaItems(query: String): Flow&lt;List&lt;MediaEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM media_items WHERE album = :albumId&quot;)&#10;    fun getMediaItemsByAlbum(albumId: String): Flow&lt;List&lt;MediaEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM media_items WHERE artist = :artistId&quot;)&#10;    fun getMediaItemsByArtist(artistId: String): Flow&lt;List&lt;MediaEntity&gt;&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertMediaItem(mediaItem: MediaEntity)&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertMediaItems(mediaItems: List&lt;MediaEntity&gt;)&#10;    &#10;    @Update&#10;    suspend fun updateMediaItem(mediaItem: MediaEntity)&#10;    &#10;    @Delete&#10;    suspend fun deleteMediaItem(mediaItem: MediaEntity)&#10;    &#10;    @Query(&quot;DELETE FROM media_items&quot;)&#10;    suspend fun deleteAllMediaItems()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/dao/PlaylistDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/dao/PlaylistDao.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.local.database.dao&#10;&#10;import androidx.room.*&#10;import com.tinhtx.player.local.database.entities.PlaylistEntity&#10;import com.tinhtx.player.local.database.entities.PlaylistMediaEntity&#10;import com.tinhtx.player.local.database.entities.MediaEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface PlaylistDao {&#10;    &#10;    @Query(&quot;SELECT * FROM playlists&quot;)&#10;    fun getAllPlaylists(): Flow&lt;List&lt;PlaylistEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM playlists WHERE id = :id&quot;)&#10;    fun getPlaylistById(id: String): Flow&lt;PlaylistEntity?&gt;&#10;    &#10;    @Query(&quot;&quot;&quot;&#10;        SELECT m.* FROM media_items m&#10;        INNER JOIN playlist_media pm ON m.id = pm.mediaId&#10;        WHERE pm.playlistId = :playlistId&#10;        ORDER BY pm.position&#10;    &quot;&quot;&quot;)&#10;    fun getPlaylistItems(playlistId: String): Flow&lt;List&lt;MediaEntity&gt;&gt;&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertPlaylist(playlist: PlaylistEntity)&#10;    &#10;    @Update&#10;    suspend fun updatePlaylist(playlist: PlaylistEntity)&#10;    &#10;    @Delete&#10;    suspend fun deletePlaylist(playlist: PlaylistEntity)&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertPlaylistMedia(playlistMedia: PlaylistMediaEntity)&#10;    &#10;    @Query(&quot;DELETE FROM playlist_media WHERE playlistId = :playlistId AND mediaId = :mediaId&quot;)&#10;    suspend fun removePlaylistMedia(playlistId: String, mediaId: String)&#10;    &#10;    @Query(&quot;DELETE FROM playlist_media WHERE playlistId = :playlistId&quot;)&#10;    suspend fun clearPlaylist(playlistId: String)&#10;    &#10;    @Query(&quot;UPDATE playlist_media SET position = :newPosition WHERE playlistId = :playlistId AND mediaId = :mediaId&quot;)&#10;    suspend fun updateMediaPosition(playlistId: String, mediaId: String, newPosition: Int)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/entities/MediaEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/entities/MediaEntity.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.local.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;media_items&quot;)&#10;data class MediaEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val title: String,&#10;    val artist: String,&#10;    val album: String,&#10;    val duration: Long,&#10;    val uri: String,&#10;    val artworkUri: String? = null,&#10;    val mediaType: String,&#10;    val size: Long = 0,&#10;    val dateAdded: Long = 0,&#10;    val path: String = &quot;&quot;,&#10;    val mimeType: String = &quot;&quot;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/entities/PlaylistEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/entities/PlaylistEntity.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.local.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;playlists&quot;)&#10;data class PlaylistEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val name: String,&#10;    val description: String = &quot;&quot;,&#10;    val artworkUri: String? = null,&#10;    val trackCount: Int = 0,&#10;    val duration: Long = 0,&#10;    val dateCreated: Long = System.currentTimeMillis(),&#10;    val dateModified: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/entities/PlaylistMediaEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/database/entities/PlaylistMediaEntity.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.local.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;&#10;@Entity(&#10;    tableName = &quot;playlist_media&quot;,&#10;    primaryKeys = [&quot;playlistId&quot;, &quot;mediaId&quot;],&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = PlaylistEntity::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;playlistId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        ),&#10;        ForeignKey(&#10;            entity = MediaEntity::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;mediaId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;playlistId&quot;]),&#10;        Index(value = [&quot;mediaId&quot;])&#10;    ]&#10;)&#10;data class PlaylistMediaEntity(&#10;    val playlistId: String,&#10;    val mediaId: String,&#10;    val position: Int,&#10;    val dateAdded: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/preferences/UserPreferencesManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/local/preferences/UserPreferencesManager.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.local.preferences&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import com.tinhtx.player.model.AppTheme&#10;import com.tinhtx.player.model.RepeatMode&#10;import com.tinhtx.player.model.UserSettings&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class UserPreferencesManager @Inject constructor(&#10;    context: Context&#10;) {&#10;    private val preferences: SharedPreferences = context.getSharedPreferences(&#10;        &quot;tinhtx_player_preferences&quot;,&#10;        Context.MODE_PRIVATE&#10;    )&#10;    &#10;    fun getUserSettings(): UserSettings {&#10;        return UserSettings(&#10;            theme = AppTheme.valueOf(preferences.getString(KEY_THEME, AppTheme.SYSTEM.name) ?: AppTheme.SYSTEM.name),&#10;            playbackSpeed = preferences.getFloat(KEY_PLAYBACK_SPEED, 1.0f),&#10;            repeatMode = RepeatMode.valueOf(preferences.getString(KEY_REPEAT_MODE, RepeatMode.OFF.name) ?: RepeatMode.OFF.name),&#10;            shuffleMode = preferences.getBoolean(KEY_SHUFFLE_MODE, false),&#10;            autoPlayNext = preferences.getBoolean(KEY_AUTO_PLAY_NEXT, true),&#10;            showNotification = preferences.getBoolean(KEY_SHOW_NOTIFICATION, true),&#10;            equalizerEnabled = preferences.getBoolean(KEY_EQUALIZER_ENABLED, false),&#10;            bassBoostLevel = preferences.getInt(KEY_BASS_BOOST, 0),&#10;            virtualizerLevel = preferences.getInt(KEY_VIRTUALIZER, 0),&#10;            skipSilence = preferences.getBoolean(KEY_SKIP_SILENCE, false),&#10;            crossfadeDuration = preferences.getInt(KEY_CROSSFADE_DURATION, 0)&#10;        )&#10;    }&#10;    &#10;    fun saveUserSettings(settings: UserSettings) {&#10;        preferences.edit().apply {&#10;            putString(KEY_THEME, settings.theme.name)&#10;            putFloat(KEY_PLAYBACK_SPEED, settings.playbackSpeed)&#10;            putString(KEY_REPEAT_MODE, settings.repeatMode.name)&#10;            putBoolean(KEY_SHUFFLE_MODE, settings.shuffleMode)&#10;            putBoolean(KEY_AUTO_PLAY_NEXT, settings.autoPlayNext)&#10;            putBoolean(KEY_SHOW_NOTIFICATION, settings.showNotification)&#10;            putBoolean(KEY_EQUALIZER_ENABLED, settings.equalizerEnabled)&#10;            putInt(KEY_BASS_BOOST, settings.bassBoostLevel)&#10;            putInt(KEY_VIRTUALIZER, settings.virtualizerLevel)&#10;            putBoolean(KEY_SKIP_SILENCE, settings.skipSilence)&#10;            putInt(KEY_CROSSFADE_DURATION, settings.crossfadeDuration)&#10;            apply()&#10;        }&#10;    }&#10;    &#10;    companion object {&#10;        private const val KEY_THEME = &quot;theme&quot;&#10;        private const val KEY_PLAYBACK_SPEED = &quot;playback_speed&quot;&#10;        private const val KEY_REPEAT_MODE = &quot;repeat_mode&quot;&#10;        private const val KEY_SHUFFLE_MODE = &quot;shuffle_mode&quot;&#10;        private const val KEY_AUTO_PLAY_NEXT = &quot;auto_play_next&quot;&#10;        private const val KEY_SHOW_NOTIFICATION = &quot;show_notification&quot;&#10;        private const val KEY_EQUALIZER_ENABLED = &quot;equalizer_enabled&quot;&#10;        private const val KEY_BASS_BOOST = &quot;bass_boost&quot;&#10;        private const val KEY_VIRTUALIZER = &quot;virtualizer&quot;&#10;        private const val KEY_SKIP_SILENCE = &quot;skip_silence&quot;&#10;        private const val KEY_CROSSFADE_DURATION = &quot;crossfade_duration&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/mapper/MediaMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/mapper/MediaMapper.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.mapper&#10;&#10;import com.tinhtx.player.local.database.entities.MediaEntity&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.MediaType&#10;&#10;object MediaMapper {&#10;    &#10;    fun toEntity(mediaItem: MediaItem): MediaEntity {&#10;        return MediaEntity(&#10;            id = mediaItem.id,&#10;            title = mediaItem.title,&#10;            artist = mediaItem.artist,&#10;            album = mediaItem.album,&#10;            duration = mediaItem.duration,&#10;            uri = mediaItem.uri,&#10;            artworkUri = mediaItem.artworkUri,&#10;            mediaType = mediaItem.mediaType.name,&#10;            size = mediaItem.size,&#10;            dateAdded = mediaItem.dateAdded,&#10;            path = mediaItem.path,&#10;            mimeType = mediaItem.mimeType&#10;        )&#10;    }&#10;    &#10;    fun toDomain(entity: MediaEntity): MediaItem {&#10;        return MediaItem(&#10;            id = entity.id,&#10;            title = entity.title,&#10;            artist = entity.artist,&#10;            album = entity.album,&#10;            duration = entity.duration,&#10;            uri = entity.uri,&#10;            artworkUri = entity.artworkUri,&#10;            mediaType = MediaType.valueOf(entity.mediaType),&#10;            size = entity.size,&#10;            dateAdded = entity.dateAdded,&#10;            path = entity.path,&#10;            mimeType = entity.mimeType&#10;        )&#10;    }&#10;    &#10;    fun toEntityList(mediaItems: List&lt;MediaItem&gt;): List&lt;MediaEntity&gt; {&#10;        return mediaItems.map { toEntity(it) }&#10;    }&#10;    &#10;    fun toDomainList(entities: List&lt;MediaEntity&gt;): List&lt;MediaItem&gt; {&#10;        return entities.map { toDomain(it) }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/mapper/PlaylistMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/mapper/PlaylistMapper.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.mapper&#10;&#10;import com.tinhtx.player.local.database.entities.PlaylistEntity&#10;import com.tinhtx.player.model.PlaylistInfo&#10;&#10;object PlaylistMapper {&#10;    &#10;    fun toEntity(playlistInfo: PlaylistInfo): PlaylistEntity {&#10;        return PlaylistEntity(&#10;            id = playlistInfo.id,&#10;            name = playlistInfo.name,&#10;            description = playlistInfo.description,&#10;            artworkUri = playlistInfo.artworkUri,&#10;            trackCount = playlistInfo.trackCount,&#10;            duration = playlistInfo.duration,&#10;            dateCreated = playlistInfo.dateCreated,&#10;            dateModified = playlistInfo.dateModified&#10;        )&#10;    }&#10;    &#10;    fun toDomain(entity: PlaylistEntity): PlaylistInfo {&#10;        return PlaylistInfo(&#10;            id = entity.id,&#10;            name = entity.name,&#10;            description = entity.description,&#10;            artworkUri = entity.artworkUri,&#10;            trackCount = entity.trackCount,&#10;            duration = entity.duration,&#10;            dateCreated = entity.dateCreated,&#10;            dateModified = entity.dateModified&#10;        )&#10;    }&#10;    &#10;    fun toEntityList(playlists: List&lt;PlaylistInfo&gt;): List&lt;PlaylistEntity&gt; {&#10;        return playlists.map { toEntity(it) }&#10;    }&#10;    &#10;    fun toDomainList(entities: List&lt;PlaylistEntity&gt;): List&lt;PlaylistInfo&gt; {&#10;        return entities.map { toDomain(it) }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/repository/MediaRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/repository/MediaRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.repository&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.local.database.dao.MediaDao&#10;import com.tinhtx.player.mapper.MediaMapper&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.AlbumInfo&#10;import com.tinhtx.player.model.ArtistInfo&#10;import com.tinhtx.player.model.SortOrder&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.catch&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class MediaRepositoryImpl @Inject constructor(&#10;    private val mediaDao: MediaDao&#10;) : MediaRepository {&#10;    &#10;    override fun getAllMediaItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaDao.getAllMediaItems()&#10;            .map { entities -&gt;&#10;                Resource.Success(MediaMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get media items: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun getAudioItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaDao.getAudioItems()&#10;            .map { entities -&gt;&#10;                Resource.Success(MediaMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get audio items: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun getVideoItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaDao.getVideoItems()&#10;            .map { entities -&gt;&#10;                Resource.Success(MediaMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get video items: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun getMediaItemById(id: String): Flow&lt;Resource&lt;MediaItem?&gt;&gt; {&#10;        return mediaDao.getMediaItemById(id)&#10;            .map { entity -&gt;&#10;                Resource.Success(entity?.let { MediaMapper.toDomain(it) })&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get media item: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun getAlbums(): Flow&lt;Resource&lt;List&lt;AlbumInfo&gt;&gt;&gt; {&#10;        // This would be implemented with proper album aggregation logic&#10;        return getAllMediaItems().map { resource -&gt;&#10;            when (resource) {&#10;                is Resource.Success -&gt; {&#10;                    val albums = resource.data?.groupBy { it.album }?.map { (albumName, items) -&gt;&#10;                        AlbumInfo(&#10;                            id = items.first().album,&#10;                            name = albumName,&#10;                            artist = items.first().artist,&#10;                            artworkUri = items.first().artworkUri,&#10;                            trackCount = items.size,&#10;                            duration = items.sumOf { it.duration }&#10;                        )&#10;                    } ?: emptyList()&#10;                    Resource.Success(albums)&#10;                }&#10;                is Resource.Error -&gt; Resource.Error(resource.message ?: &quot;Unknown error&quot;)&#10;                is Resource.Loading -&gt; Resource.Loading()&#10;            }&#10;        }&#10;    }&#10;    &#10;    override fun getArtists(): Flow&lt;Resource&lt;List&lt;ArtistInfo&gt;&gt;&gt; {&#10;        return getAllMediaItems().map { resource -&gt;&#10;            when (resource) {&#10;                is Resource.Success -&gt; {&#10;                    val artists = resource.data?.groupBy { it.artist }?.map { (artistName, items) -&gt;&#10;                        ArtistInfo(&#10;                            id = artistName,&#10;                            name = artistName,&#10;                            trackCount = items.size,&#10;                            albumCount = items.map { it.album }.distinct().size,&#10;                            artworkUri = items.first().artworkUri&#10;                        )&#10;                    } ?: emptyList()&#10;                    Resource.Success(artists)&#10;                }&#10;                is Resource.Error -&gt; Resource.Error(resource.message ?: &quot;Unknown error&quot;)&#10;                is Resource.Loading -&gt; Resource.Loading()&#10;            }&#10;        }&#10;    }&#10;    &#10;    override fun getMediaItemsByAlbum(albumId: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaDao.getMediaItemsByAlbum(albumId)&#10;            .map { entities -&gt;&#10;                Resource.Success(MediaMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get album items: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun getMediaItemsByArtist(artistId: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaDao.getMediaItemsByArtist(artistId)&#10;            .map { entities -&gt;&#10;                Resource.Success(MediaMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get artist items: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun searchMediaItems(query: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaDao.searchMediaItems(query)&#10;            .map { entities -&gt;&#10;                Resource.Success(MediaMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to search media items: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun sortMediaItems(items: List&lt;MediaItem&gt;, sortOrder: SortOrder): List&lt;MediaItem&gt; {&#10;        return when (sortOrder) {&#10;            SortOrder.TITLE_ASC -&gt; items.sortedBy { it.title }&#10;            SortOrder.TITLE_DESC -&gt; items.sortedByDescending { it.title }&#10;            SortOrder.ARTIST_ASC -&gt; items.sortedBy { it.artist }&#10;            SortOrder.ARTIST_DESC -&gt; items.sortedByDescending { it.artist }&#10;            SortOrder.ALBUM_ASC -&gt; items.sortedBy { it.album }&#10;            SortOrder.ALBUM_DESC -&gt; items.sortedByDescending { it.album }&#10;            SortOrder.DURATION_ASC -&gt; items.sortedBy { it.duration }&#10;            SortOrder.DURATION_DESC -&gt; items.sortedByDescending { it.duration }&#10;            SortOrder.DATE_ADDED_ASC -&gt; items.sortedBy { it.dateAdded }&#10;            SortOrder.DATE_ADDED_DESC -&gt; items.sortedByDescending { it.dateAdded }&#10;        }&#10;    }&#10;    &#10;    override suspend fun scanMediaFiles(): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This would be implemented with actual media scanning logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to scan media files: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    override suspend fun refreshMediaLibrary(): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This would be implemented with actual refresh logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to refresh media library: ${e.message}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/repository/PlaylistRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/main/kotlin/com/tinhtx/player/repository/PlaylistRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.repository&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.local.database.dao.PlaylistDao&#10;import com.tinhtx.player.local.database.entities.PlaylistMediaEntity&#10;import com.tinhtx.player.mapper.MediaMapper&#10;import com.tinhtx.player.mapper.PlaylistMapper&#10;import com.tinhtx.player.model.PlaylistInfo&#10;import com.tinhtx.player.model.MediaItem&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.catch&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class PlaylistRepositoryImpl @Inject constructor(&#10;    private val playlistDao: PlaylistDao&#10;) : PlaylistRepository {&#10;    &#10;    override fun getAllPlaylists(): Flow&lt;Resource&lt;List&lt;PlaylistInfo&gt;&gt;&gt; {&#10;        return playlistDao.getAllPlaylists()&#10;            .map { entities -&gt;&#10;                Resource.Success(PlaylistMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get playlists: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun getPlaylistById(id: String): Flow&lt;Resource&lt;PlaylistInfo?&gt;&gt; {&#10;        return playlistDao.getPlaylistById(id)&#10;            .map { entity -&gt;&#10;                Resource.Success(entity?.let { PlaylistMapper.toDomain(it) })&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get playlist: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override fun getPlaylistItems(playlistId: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return playlistDao.getPlaylistItems(playlistId)&#10;            .map { entities -&gt;&#10;                Resource.Success(MediaMapper.toDomainList(entities))&#10;            }&#10;            .catch { e -&gt;&#10;                emit(Resource.Error(&quot;Failed to get playlist items: ${e.message}&quot;))&#10;            }&#10;    }&#10;    &#10;    override suspend fun createPlaylist(name: String, description: String): Resource&lt;PlaylistInfo&gt; {&#10;        return try {&#10;            val playlist = PlaylistInfo(&#10;                id = UUID.randomUUID().toString(),&#10;                name = name,&#10;                description = description&#10;            )&#10;            playlistDao.insertPlaylist(PlaylistMapper.toEntity(playlist))&#10;            Resource.Success(playlist)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to create playlist: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    override suspend fun updatePlaylist(playlist: PlaylistInfo): Resource&lt;Unit&gt; {&#10;        return try {&#10;            playlistDao.updatePlaylist(PlaylistMapper.toEntity(playlist))&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to update playlist: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    override suspend fun deletePlaylist(playlistId: String): Resource&lt;Unit&gt; {&#10;        return try {&#10;            val playlist = playlistDao.getPlaylistById(playlistId)&#10;            // Note: This is a simplified approach. In a real implementation,&#10;            // you'd need to handle the Flow properly&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to delete playlist: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    override suspend fun addItemToPlaylist(playlistId: String, mediaItem: MediaItem): Resource&lt;Unit&gt; {&#10;        return try {&#10;            val playlistMedia = PlaylistMediaEntity(&#10;                playlistId = playlistId,&#10;                mediaId = mediaItem.id,&#10;                position = 0 // This would be calculated based on existing items&#10;            )&#10;            playlistDao.insertPlaylistMedia(playlistMedia)&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to add item to playlist: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    override suspend fun removeItemFromPlaylist(playlistId: String, mediaItemId: String): Resource&lt;Unit&gt; {&#10;        return try {&#10;            playlistDao.removePlaylistMedia(playlistId, mediaItemId)&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to remove item from playlist: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    override suspend fun reorderPlaylistItems(playlistId: String, fromIndex: Int, toIndex: Int): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This would implement the reordering logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to reorder playlist items: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    override suspend fun clearPlaylist(playlistId: String): Resource&lt;Unit&gt; {&#10;        return try {&#10;            playlistDao.clearPlaylist(playlistId)&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to clear playlist: ${e.message}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/test/kotlin/com/tinhtx/player/local/database/MediaDaoTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/test/kotlin/com/tinhtx/player/local/database/MediaDaoTest.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.local.database&#10;&#10;import androidx.room.Room&#10;import androidx.test.core.app.ApplicationProvider&#10;import androidx.test.ext.junit.runners.AndroidJUnit4&#10;import com.tinhtx.player.local.database.dao.MediaDao&#10;import com.tinhtx.player.local.database.entities.MediaEntity&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.test.runTest&#10;import org.junit.After&#10;import org.junit.Before&#10;import org.junit.Test&#10;import org.junit.Assert.*&#10;import org.junit.runner.RunWith&#10;&#10;@RunWith(AndroidJUnit4::class)&#10;class MediaDaoTest {&#10;    &#10;    private lateinit var database: AppDatabase&#10;    private lateinit var mediaDao: MediaDao&#10;    &#10;    @Before&#10;    fun setup() {&#10;        database = Room.inMemoryDatabaseBuilder(&#10;            ApplicationProvider.getApplicationContext(),&#10;            AppDatabase::class.java&#10;        ).allowMainThreadQueries().build()&#10;        &#10;        mediaDao = database.mediaDao()&#10;    }&#10;    &#10;    @After&#10;    fun teardown() {&#10;        database.close()&#10;    }&#10;    &#10;    @Test&#10;    fun insertAndGetMediaItem() = runTest {&#10;        val mediaItem = MediaEntity(&#10;            id = &quot;1&quot;,&#10;            title = &quot;Test Song&quot;,&#10;            artist = &quot;Test Artist&quot;,&#10;            album = &quot;Test Album&quot;,&#10;            duration = 180000,&#10;            uri = &quot;content://test&quot;,&#10;            mediaType = &quot;AUDIO&quot;&#10;        )&#10;        &#10;        mediaDao.insertMediaItem(mediaItem)&#10;        val result = mediaDao.getMediaItemById(&quot;1&quot;).first()&#10;        &#10;        assertEquals(mediaItem, result)&#10;    }&#10;    &#10;    @Test&#10;    fun getAllMediaItems() = runTest {&#10;        val mediaItems = listOf(&#10;            MediaEntity(&quot;1&quot;, &quot;Song 1&quot;, &quot;Artist 1&quot;, &quot;Album 1&quot;, 180000, &quot;uri1&quot;, mediaType = &quot;AUDIO&quot;),&#10;            MediaEntity(&quot;2&quot;, &quot;Song 2&quot;, &quot;Artist 2&quot;, &quot;Album 2&quot;, 200000, &quot;uri2&quot;, mediaType = &quot;AUDIO&quot;)&#10;        )&#10;        &#10;        mediaDao.insertMediaItems(mediaItems)&#10;        val result = mediaDao.getAllMediaItems().first()&#10;        &#10;        assertEquals(2, result.size)&#10;    }&#10;    &#10;    @Test&#10;    fun searchMediaItems() = runTest {&#10;        val mediaItem = MediaEntity(&#10;            id = &quot;1&quot;,&#10;            title = &quot;Test Song&quot;,&#10;            artist = &quot;Test Artist&quot;,&#10;            album = &quot;Test Album&quot;,&#10;            duration = 180000,&#10;            uri = &quot;content://test&quot;,&#10;            mediaType = &quot;AUDIO&quot;&#10;        )&#10;        &#10;        mediaDao.insertMediaItem(mediaItem)&#10;        val result = mediaDao.searchMediaItems(&quot;Test&quot;).first()&#10;        &#10;        assertEquals(1, result.size)&#10;        assertEquals(mediaItem, result.first())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/src/test/kotlin/com/tinhtx/player/repository/MediaRepositoryImplTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/src/test/kotlin/com/tinhtx/player/repository/MediaRepositoryImplTest.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.repository&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.local.database.dao.MediaDao&#10;import com.tinhtx.player.local.database.entities.MediaEntity&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.MediaType&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.test.runTest&#10;import org.junit.Test&#10;import org.junit.Assert.*&#10;import org.mockito.Mock&#10;import org.mockito.Mockito.*&#10;import org.mockito.junit.MockitoJUnitRunner&#10;import org.junit.runner.RunWith&#10;&#10;@RunWith(MockitoJUnitRunner::class)&#10;class MediaRepositoryImplTest {&#10;    &#10;    @Mock&#10;    private lateinit var mediaDao: MediaDao&#10;    &#10;    private lateinit var repository: MediaRepositoryImpl&#10;    &#10;    @Test&#10;    fun `getAllMediaItems should return success resource`() = runTest {&#10;        // Given&#10;        val entities = listOf(&#10;            MediaEntity(&quot;1&quot;, &quot;Song 1&quot;, &quot;Artist 1&quot;, &quot;Album 1&quot;, 180000, &quot;uri1&quot;, mediaType = &quot;AUDIO&quot;)&#10;        )&#10;        `when`(mediaDao.getAllMediaItems()).thenReturn(flowOf(entities))&#10;        &#10;        repository = MediaRepositoryImpl(mediaDao)&#10;        &#10;        // When&#10;        val result = repository.getAllMediaItems().first()&#10;        &#10;        // Then&#10;        assertTrue(result is Resource.Success)&#10;        assertEquals(1, result.data?.size)&#10;        assertEquals(&quot;Song 1&quot;, result.data?.first()?.title)&#10;    }&#10;    &#10;    @Test&#10;    fun `getAudioItems should return only audio items`() = runTest {&#10;        // Given&#10;        val entities = listOf(&#10;            MediaEntity(&quot;1&quot;, &quot;Song 1&quot;, &quot;Artist 1&quot;, &quot;Album 1&quot;, 180000, &quot;uri1&quot;, mediaType = &quot;AUDIO&quot;)&#10;        )&#10;        `when`(mediaDao.getAudioItems()).thenReturn(flowOf(entities))&#10;        &#10;        repository = MediaRepositoryImpl(mediaDao)&#10;        &#10;        // When&#10;        val result = repository.getAudioItems().first()&#10;        &#10;        // Then&#10;        assertTrue(result is Resource.Success)&#10;        assertEquals(MediaType.AUDIO, result.data?.first()?.mediaType)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/AlbumInfo.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/AlbumInfo.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.model&#10;&#10;data class AlbumInfo(&#10;    val id: String,&#10;    val name: String,&#10;    val artist: String,&#10;    val artworkUri: String? = null,&#10;    val trackCount: Int = 0,&#10;    val year: Int? = null,&#10;    val duration: Long = 0&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/ArtistInfo.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/ArtistInfo.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.model&#10;&#10;data class ArtistInfo(&#10;    val id: String,&#10;    val name: String,&#10;    val albumCount: Int = 0,&#10;    val trackCount: Int = 0,&#10;    val artworkUri: String? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/Enums.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/Enums.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.model&#10;&#10;enum class MediaType {&#10;    AUDIO,&#10;    VIDEO&#10;}&#10;&#10;enum class RepeatMode {&#10;    OFF,&#10;    ONE,&#10;    ALL&#10;}&#10;&#10;enum class AppTheme {&#10;    LIGHT,&#10;    DARK,&#10;    SYSTEM&#10;}&#10;&#10;enum class SortOrder {&#10;    TITLE_ASC,&#10;    TITLE_DESC,&#10;    ARTIST_ASC,&#10;    ARTIST_DESC,&#10;    ALBUM_ASC,&#10;    ALBUM_DESC,&#10;    DURATION_ASC,&#10;    DURATION_DESC,&#10;    DATE_ADDED_ASC,&#10;    DATE_ADDED_DESC&#10;}&#10;&#10;enum class PlaybackError {&#10;    NETWORK_ERROR,&#10;    FILE_NOT_FOUND,&#10;    PERMISSION_DENIED,&#10;    UNSUPPORTED_FORMAT,&#10;    UNKNOWN_ERROR&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/MediaItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/MediaItem.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.model&#10;&#10;data class MediaItem(&#10;    val id: String,&#10;    val title: String,&#10;    val artist: String,&#10;    val album: String,&#10;    val duration: Long,&#10;    val uri: String,&#10;    val artworkUri: String? = null,&#10;    val mediaType: MediaType,&#10;    val size: Long = 0,&#10;    val dateAdded: Long = 0,&#10;    val path: String = &quot;&quot;,&#10;    val mimeType: String = &quot;&quot;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/PlaybackState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/PlaybackState.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.model&#10;&#10;data class PlaybackState(&#10;    val isPlaying: Boolean = false,&#10;    val currentMediaItem: MediaItem? = null,&#10;    val currentPosition: Long = 0L,&#10;    val bufferedPosition: Long = 0L,&#10;    val playbackSpeed: Float = 1.0f,&#10;    val repeatMode: RepeatMode = RepeatMode.OFF,&#10;    val shuffleModeEnabled: Boolean = false,&#10;    val queue: List&lt;MediaItem&gt; = emptyList(),&#10;    val currentIndex: Int = -1&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/PlaylistInfo.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/PlaylistInfo.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.model&#10;&#10;data class PlaylistInfo(&#10;    val id: String,&#10;    val name: String,&#10;    val description: String = &quot;&quot;,&#10;    val artworkUri: String? = null,&#10;    val trackCount: Int = 0,&#10;    val duration: Long = 0,&#10;    val dateCreated: Long = System.currentTimeMillis(),&#10;    val dateModified: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/UserSettings.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/model/UserSettings.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.model&#10;&#10;data class UserSettings(&#10;    val theme: AppTheme = AppTheme.SYSTEM,&#10;    val playbackSpeed: Float = 1.0f,&#10;    val repeatMode: RepeatMode = RepeatMode.OFF,&#10;    val shuffleMode: Boolean = false,&#10;    val autoPlayNext: Boolean = true,&#10;    val showNotification: Boolean = true,&#10;    val equalizerEnabled: Boolean = false,&#10;    val bassBoostLevel: Int = 0,&#10;    val virtualizerLevel: Int = 0,&#10;    val skipSilence: Boolean = false,&#10;    val crossfadeDuration: Int = 0&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/repository/MediaRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/repository/MediaRepository.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.repository&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.AlbumInfo&#10;import com.tinhtx.player.model.ArtistInfo&#10;import com.tinhtx.player.model.SortOrder&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface MediaRepository {&#10;    &#10;    fun getAllMediaItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt;&#10;    &#10;    fun getAudioItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt;&#10;    &#10;    fun getVideoItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt;&#10;    &#10;    fun getMediaItemById(id: String): Flow&lt;Resource&lt;MediaItem?&gt;&gt;&#10;    &#10;    fun getAlbums(): Flow&lt;Resource&lt;List&lt;AlbumInfo&gt;&gt;&gt;&#10;    &#10;    fun getArtists(): Flow&lt;Resource&lt;List&lt;ArtistInfo&gt;&gt;&gt;&#10;    &#10;    fun getMediaItemsByAlbum(albumId: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt;&#10;    &#10;    fun getMediaItemsByArtist(artistId: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt;&#10;    &#10;    fun searchMediaItems(query: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt;&#10;    &#10;    fun sortMediaItems(items: List&lt;MediaItem&gt;, sortOrder: SortOrder): List&lt;MediaItem&gt;&#10;    &#10;    suspend fun scanMediaFiles(): Resource&lt;Unit&gt;&#10;    &#10;    suspend fun refreshMediaLibrary(): Resource&lt;Unit&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/repository/PlaylistRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/repository/PlaylistRepository.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.repository&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.model.PlaylistInfo&#10;import com.tinhtx.player.model.MediaItem&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;interface PlaylistRepository {&#10;    &#10;    fun getAllPlaylists(): Flow&lt;Resource&lt;List&lt;PlaylistInfo&gt;&gt;&gt;&#10;    &#10;    fun getPlaylistById(id: String): Flow&lt;Resource&lt;PlaylistInfo?&gt;&gt;&#10;    &#10;    fun getPlaylistItems(playlistId: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt;&#10;    &#10;    suspend fun createPlaylist(name: String, description: String = &quot;&quot;): Resource&lt;PlaylistInfo&gt;&#10;    &#10;    suspend fun updatePlaylist(playlist: PlaylistInfo): Resource&lt;Unit&gt;&#10;    &#10;    suspend fun deletePlaylist(playlistId: String): Resource&lt;Unit&gt;&#10;    &#10;    suspend fun addItemToPlaylist(playlistId: String, mediaItem: MediaItem): Resource&lt;Unit&gt;&#10;    &#10;    suspend fun removeItemFromPlaylist(playlistId: String, mediaItemId: String): Resource&lt;Unit&gt;&#10;    &#10;    suspend fun reorderPlaylistItems(playlistId: String, fromIndex: Int, toIndex: Int): Resource&lt;Unit&gt;&#10;    &#10;    suspend fun clearPlaylist(playlistId: String): Resource&lt;Unit&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/usecase/GetMediaItemsUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/usecase/GetMediaItemsUseCase.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.usecase&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.SortOrder&#10;import com.tinhtx.player.repository.MediaRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import javax.inject.Inject&#10;&#10;class GetMediaItemsUseCase @Inject constructor(&#10;    private val mediaRepository: MediaRepository&#10;) {&#10;    &#10;    fun getAllMediaItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaRepository.getAllMediaItems()&#10;    }&#10;    &#10;    fun getAudioItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaRepository.getAudioItems()&#10;    }&#10;    &#10;    fun getVideoItems(): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaRepository.getVideoItems()&#10;    }&#10;    &#10;    fun getMediaItemById(id: String): Flow&lt;Resource&lt;MediaItem?&gt;&gt; {&#10;        return mediaRepository.getMediaItemById(id)&#10;    }&#10;    &#10;    fun searchMediaItems(query: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return mediaRepository.searchMediaItems(query)&#10;    }&#10;    &#10;    suspend fun refreshMediaLibrary(): Resource&lt;Unit&gt; {&#10;        return mediaRepository.refreshMediaLibrary()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/usecase/ManagePlaylistUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/usecase/ManagePlaylistUseCase.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.usecase&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.model.PlaylistInfo&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.repository.PlaylistRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import javax.inject.Inject&#10;&#10;class ManagePlaylistUseCase @Inject constructor(&#10;    private val playlistRepository: PlaylistRepository&#10;) {&#10;    &#10;    fun getAllPlaylists(): Flow&lt;Resource&lt;List&lt;PlaylistInfo&gt;&gt;&gt; {&#10;        return playlistRepository.getAllPlaylists()&#10;    }&#10;    &#10;    fun getPlaylistById(id: String): Flow&lt;Resource&lt;PlaylistInfo?&gt;&gt; {&#10;        return playlistRepository.getPlaylistById(id)&#10;    }&#10;    &#10;    fun getPlaylistItems(playlistId: String): Flow&lt;Resource&lt;List&lt;MediaItem&gt;&gt;&gt; {&#10;        return playlistRepository.getPlaylistItems(playlistId)&#10;    }&#10;    &#10;    suspend fun createPlaylist(name: String, description: String = &quot;&quot;): Resource&lt;PlaylistInfo&gt; {&#10;        return playlistRepository.createPlaylist(name, description)&#10;    }&#10;    &#10;    suspend fun updatePlaylist(playlist: PlaylistInfo): Resource&lt;Unit&gt; {&#10;        return playlistRepository.updatePlaylist(playlist)&#10;    }&#10;    &#10;    suspend fun deletePlaylist(playlistId: String): Resource&lt;Unit&gt; {&#10;        return playlistRepository.deletePlaylist(playlistId)&#10;    }&#10;    &#10;    suspend fun addItemToPlaylist(playlistId: String, mediaItem: MediaItem): Resource&lt;Unit&gt; {&#10;        return playlistRepository.addItemToPlaylist(playlistId, mediaItem)&#10;    }&#10;    &#10;    suspend fun removeItemFromPlaylist(playlistId: String, mediaItemId: String): Resource&lt;Unit&gt; {&#10;        return playlistRepository.removeItemFromPlaylist(playlistId, mediaItemId)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/usecase/PlayMediaUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/main/kotlin/com/tinhtx/player/usecase/PlayMediaUseCase.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.usecase&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.PlaybackState&#10;import javax.inject.Inject&#10;&#10;class PlayMediaUseCase @Inject constructor() {&#10;    &#10;    suspend fun playMedia(mediaItem: MediaItem): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This will be implemented with actual media player logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to play media: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    suspend fun pauseMedia(): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This will be implemented with actual media player logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to pause media: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    suspend fun stopMedia(): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This will be implemented with actual media player logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to stop media: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    suspend fun seekTo(position: Long): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This will be implemented with actual media player logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to seek: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    suspend fun skipToNext(): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This will be implemented with actual media player logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to skip to next: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    suspend fun skipToPrevious(): Resource&lt;Unit&gt; {&#10;        return try {&#10;            // This will be implemented with actual media player logic&#10;            Resource.Success(Unit)&#10;        } catch (e: Exception) {&#10;            Resource.Error(&quot;Failed to skip to previous: ${e.message}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/domain/src/test/kotlin/com/tinhtx/player/usecase/GetMediaItemsUseCaseTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/domain/src/test/kotlin/com/tinhtx/player/usecase/GetMediaItemsUseCaseTest.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.usecase&#10;&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.MediaType&#10;import com.tinhtx.player.repository.MediaRepository&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.test.runTest&#10;import org.junit.Test&#10;import org.junit.Assert.*&#10;import org.mockito.Mock&#10;import org.mockito.Mockito.*&#10;import org.mockito.junit.MockitoJUnitRunner&#10;import org.junit.runner.RunWith&#10;&#10;@RunWith(MockitoJUnitRunner::class)&#10;class GetMediaItemsUseCaseTest {&#10;    &#10;    @Mock&#10;    private lateinit var mediaRepository: MediaRepository&#10;    &#10;    private lateinit var useCase: GetMediaItemsUseCase&#10;    &#10;    @Test&#10;    fun `getAllMediaItems should return media items from repository`() = runTest {&#10;        // Given&#10;        val mediaItems = listOf(&#10;            MediaItem(&#10;                id = &quot;1&quot;,&#10;                title = &quot;Test Song&quot;,&#10;                artist = &quot;Test Artist&quot;,&#10;                album = &quot;Test Album&quot;,&#10;                duration = 180000,&#10;                uri = &quot;content://test&quot;,&#10;                mediaType = MediaType.AUDIO&#10;            )&#10;        )&#10;        val resource = Resource.Success(mediaItems)&#10;        `when`(mediaRepository.getAllMediaItems()).thenReturn(flowOf(resource))&#10;        &#10;        useCase = GetMediaItemsUseCase(mediaRepository)&#10;        &#10;        // When &amp; Then&#10;        useCase.getAllMediaItems().collect { result -&gt;&#10;            assertTrue(result is Resource.Success)&#10;            assertEquals(mediaItems, result.data)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/media/src/main/java/com/tinhtx/player/media/playback/ExoPlayerManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/media/src/main/java/com/tinhtx/player/media/playback/ExoPlayerManager.kt" />
              <option name="originalContent" value="// media/src/main/kotlin/com/tinhtx/player/media/playback/ExoPlayerManager.kt&#10;package com.tinhtx.player.media.playback&#10;&#10;import androidx.media3.common.MediaItem as ExoMediaItem&#10;import androidx.media3.common.MediaMetadata.MEDIA_TYPE_VIDEO&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.util.UnstableApi&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import androidx.media3.session.MediaSession&#10;import com.tinhtx.player.domain.model.MediaItem  // Domain model&#10;import com.tinhtx.player.domain.model.MediaType&#10;import com.tinhtx.player.domain.model.PlaybackState&#10;import com.tinhtx.player.domain.model.RepeatMode&#10;import com.tinhtx.player.domain.model.ShuffleMode&#10;import com.tinhtx.player.domain.repository.PlaybackManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.toString&#10;&#10;@Singleton&#10;class ExoPlayerManager @Inject constructor(&#10;    private val exoPlayer: ExoPlayer,&#10;    private val mediaSession: MediaSession&#10;) : PlaybackManager {&#10;&#10;    private val _playbackState = MutableStateFlow(PlaybackState())&#10;    override val playbackState: StateFlow&lt;PlaybackState&gt; = _playbackState.asStateFlow()&#10;&#10;    private val playerListener = @UnstableApi&#10;    object : Player.Listener {&#10;        override fun onPlaybackStateChanged(playbackState: Int) {&#10;            updatePlaybackState { it.copy(isPlaying = playbackState == Player.STATE_READY) }&#10;        }&#10;&#10;        override fun onMediaItemTransition(mediaItem: ExoMediaItem?, reason: Int) {&#10;            updatePlaybackState {&#10;                it.copy(currentItem = mediaItem?.toDomainModel())  // Sử dụng mapper&#10;            }&#10;        }&#10;&#10;        override fun onPositionDiscontinuity(reason: Int) {&#10;            updatePlaybackState { it.copy(playbackPosition = exoPlayer.currentPosition) }&#10;        }&#10;&#10;        override fun onPlayerError(error: PlaybackException) {&#10;            updatePlaybackState { it.copy(playbackError = error.message) }&#10;        }&#10;    }&#10;&#10;    init {&#10;        exoPlayer.addListener(playerListener)&#10;    }&#10;&#10;    override fun play() {&#10;        exoPlayer.play()&#10;    }&#10;&#10;    override fun pause() {&#10;        exoPlayer.pause()&#10;    }&#10;&#10;    override fun stop() {&#10;        exoPlayer.stop()&#10;    }&#10;&#10;    override fun seekTo(position: Long) {&#10;        exoPlayer.seekTo(position)&#10;    }&#10;&#10;    override fun seekToNext() {&#10;        exoPlayer.seekToNext()&#10;    }&#10;&#10;    override fun seekToPrevious() {&#10;        exoPlayer.seekToPrevious()&#10;    }&#10;&#10;    override fun setPlaybackSpeed(speed: Float) {&#10;        exoPlayer.setPlaybackSpeed(speed)&#10;        updatePlaybackState { it.copy(playbackSpeed = speed) }&#10;    }&#10;&#10;    override fun setRepeatMode(repeatMode: RepeatMode) {&#10;        val exoRepeatMode = when (repeatMode) {&#10;            RepeatMode.OFF -&gt; Player.REPEAT_MODE_OFF&#10;            RepeatMode.ONE -&gt; Player.REPEAT_MODE_ONE&#10;            RepeatMode.ALL -&gt; Player.REPEAT_MODE_ALL&#10;        }&#10;        exoPlayer.repeatMode = exoRepeatMode&#10;    }&#10;&#10;    override fun setShuffleMode(shuffleMode: ShuffleMode) {&#10;        exoPlayer.shuffleModeEnabled = shuffleMode == ShuffleMode.ON&#10;    }&#10;&#10;    override fun setMediaItems(mediaItems: List&lt;MediaItem&gt;) {&#10;        exoPlayer.setMediaItems(mediaItems.map { ExoMediaItem.fromUri(it.uri) })&#10;        updatePlaybackState {&#10;            it.copy(&#10;                queue = mediaItems,&#10;                currentIndex = 0&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun addMediaItem(mediaItem: MediaItem) {&#10;        exoPlayer.addMediaItem(ExoMediaItem.fromUri(mediaItem.uri))&#10;    }&#10;&#10;    override fun removeMediaItem(index: Int) {&#10;        exoPlayer.removeMediaItem(index)&#10;    }&#10;&#10;    override fun prepare() {&#10;        exoPlayer.prepare()&#10;    }&#10;&#10;    override fun release() {&#10;        exoPlayer.removeListener(playerListener)&#10;        exoPlayer.release()&#10;        mediaSession.release()&#10;    }&#10;&#10;    override fun playMediaItem(mediaItem: MediaItem) {&#10;        setMediaItems(listOf(mediaItem))&#10;        prepare()&#10;        play()&#10;    }&#10;&#10;    override fun playMediaItems(mediaItems: List&lt;MediaItem&gt;, startIndex: Int) {&#10;        setMediaItems(mediaItems)&#10;        exoPlayer.seekTo(startIndex, 0L)&#10;        prepare()&#10;        play()&#10;    }&#10;&#10;    fun getPlayer(): ExoPlayer = exoPlayer&#10;&#10;    private fun updatePlaybackState(update: (PlaybackState) -&gt; PlaybackState) {&#10;        _playbackState.value = update(_playbackState.value)&#10;    }&#10;&#10;    private fun updateCurrentMediaItem() {&#10;        val currentMediaItem = exoPlayer.currentMediaItem&#10;        updatePlaybackState {&#10;            it.copy(&#10;                currentIndex = exoPlayer.currentMediaItemIndex,&#10;                playbackPosition = exoPlayer.currentPosition,&#10;                bufferedPosition = exoPlayer.bufferedPosition&#10;            )&#10;        }&#10;    }&#10;&#10;    // Mapper extension để fix lỗi 'toDomain'&#10;    private fun ExoMediaItem.toDomainModel(): MediaItem? {&#10;        // Giả định metadata chứa thông tin cần thiết; nếu không, fetch từ repository bằng ID&#10;        return MediaItem(&#10;            id = localConfiguration?.tag as? String ?: &quot;&quot;,  // Sử dụng tag để lưu ID domain nếu có&#10;            uri = localConfiguration?.uri.toString(),&#10;            displayName = mediaMetadata.displayTitle?.toString() ?: mediaMetadata.title?.toString() ?: &quot;Unknown&quot;,&#10;            title = mediaMetadata.title?.toString() ?: &quot;Unknown Title&quot;,&#10;            artist = mediaMetadata.artist?.toString() ?: &quot;Unknown Artist&quot;,&#10;            album = mediaMetadata.albumTitle?.toString() ?: &quot;Unknown Album&quot;,&#10;            duration = 0L,  // Lấy từ ExoPlayer nếu có, hoặc fetch&#10;            size = 0L,  // Fetch nếu cần&#10;            dateAdded = 0L,&#10;            dateModified = 0L,&#10;            mimeType = localConfiguration?.mimeType ?: &quot;&quot;,&#10;            albumArtUri = mediaMetadata.artworkUri?.toString(),&#10;            track = mediaMetadata.trackNumber,&#10;            year = mediaMetadata.recordingYear,&#10;            genre = mediaMetadata.genre.toString(),&#10;            bitrate = null,  // Không có trong metadata, fetch nếu cần&#10;            sampleRate = null,&#10;            type = if (mediaMetadata.mediaType == MEDIA_TYPE_VIDEO) MediaType.VIDEO else MediaType.AUDIO,&#10;            path = localConfiguration?.uri?.path ?: &quot;&quot;,&#10;            playCount = 0,&#10;            lastPlayed = null,&#10;            isFavorite = false,&#10;            isAvailable = true&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// media/src/main/kotlin/com/tinhtx/player/media/playback/ExoPlayerManager.kt&#10;package com.tinhtx.player.media.playback&#10;&#10;import android.net.Uri&#10;import androidx.media3.common.MediaItem as ExoMediaItem&#10;import androidx.media3.common.MediaMetadata&#10;import androidx.media3.common.MediaMetadata.MEDIA_TYPE_VIDEO&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.util.UnstableApi&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import androidx.media3.session.MediaSession&#10;import com.tinhtx.player.domain.model.MediaItem  // Domain model&#10;import com.tinhtx.player.domain.model.MediaType&#10;import com.tinhtx.player.domain.model.PlaybackState&#10;import com.tinhtx.player.domain.model.RepeatMode&#10;import com.tinhtx.player.domain.model.ShuffleMode&#10;import com.tinhtx.player.domain.repository.PlaybackManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.toString&#10;&#10;@Singleton&#10;class ExoPlayerManager @Inject constructor(&#10;    private val exoPlayer: ExoPlayer,&#10;    private val mediaSession: MediaSession&#10;) : PlaybackManager {&#10;&#10;    private val _playbackState = MutableStateFlow(PlaybackState())&#10;    override val playbackState: StateFlow&lt;PlaybackState&gt; = _playbackState.asStateFlow()&#10;&#10;    private val playerListener = @UnstableApi&#10;    object : Player.Listener {&#10;        override fun onPlaybackStateChanged(playbackState: Int) {&#10;            updatePlaybackState { it.copy(isPlaying = playbackState == Player.STATE_READY) }&#10;        }&#10;&#10;        override fun onMediaItemTransition(mediaItem: ExoMediaItem?, reason: Int) {&#10;            updatePlaybackState {&#10;                it.copy(currentItem = mediaItem?.toDomainModel())  // Sử dụng mapper&#10;            }&#10;        }&#10;&#10;        override fun onPositionDiscontinuity(reason: Int) {&#10;            updatePlaybackState { it.copy(playbackPosition = exoPlayer.currentPosition) }&#10;        }&#10;&#10;        override fun onPlayerError(error: PlaybackException) {&#10;            updatePlaybackState { it.copy(playbackError = error.message) }&#10;        }&#10;    }&#10;&#10;    init {&#10;        exoPlayer.addListener(playerListener)&#10;    }&#10;&#10;    override fun play() {&#10;        exoPlayer.play()&#10;    }&#10;&#10;    override fun pause() {&#10;        exoPlayer.pause()&#10;    }&#10;&#10;    override fun stop() {&#10;        exoPlayer.stop()&#10;    }&#10;&#10;    override fun seekTo(position: Long) {&#10;        exoPlayer.seekTo(position)&#10;    }&#10;&#10;    override fun seekToNext() {&#10;        exoPlayer.seekToNext()&#10;    }&#10;&#10;    override fun seekToPrevious() {&#10;        exoPlayer.seekToPrevious()&#10;    }&#10;&#10;    override fun setPlaybackSpeed(speed: Float) {&#10;        exoPlayer.setPlaybackSpeed(speed)&#10;        updatePlaybackState { it.copy(playbackSpeed = speed) }&#10;    }&#10;&#10;    override fun setRepeatMode(repeatMode: RepeatMode) {&#10;        val exoRepeatMode = when (repeatMode) {&#10;            RepeatMode.OFF -&gt; Player.REPEAT_MODE_OFF&#10;            RepeatMode.ONE -&gt; Player.REPEAT_MODE_ONE&#10;            RepeatMode.ALL -&gt; Player.REPEAT_MODE_ALL&#10;        }&#10;        exoPlayer.repeatMode = exoRepeatMode&#10;    }&#10;&#10;    override fun setShuffleMode(shuffleMode: ShuffleMode) {&#10;        exoPlayer.shuffleModeEnabled = shuffleMode == ShuffleMode.ON&#10;    }&#10;&#10;    override fun setMediaItems(mediaItems: List&lt;MediaItem&gt;) {&#10;        val exoMediaItems = mediaItems.map { domainMediaItem -&gt;&#10;            ExoMediaItem.Builder()&#10;                .setUri(domainMediaItem.uri)&#10;                .setMediaId(domainMediaItem.id)&#10;                .setTag(domainMediaItem.id) // Lưu ID để có thể map ngược lại&#10;                .setMediaMetadata(&#10;                    MediaMetadata.Builder()&#10;                        .setTitle(domainMediaItem.title)&#10;                        .setArtist(domainMediaItem.artist)&#10;                        .setAlbumTitle(domainMediaItem.album)&#10;                        .setDisplayTitle(domainMediaItem.displayName)&#10;                        .setGenre(domainMediaItem.genre)&#10;                        .setTrackNumber(domainMediaItem.track)&#10;                        .setRecordingYear(domainMediaItem.year)&#10;                        .setArtworkUri(domainMediaItem.albumArtUri?.let { Uri.parse(it) })&#10;                        .setMediaType(&#10;                            when (domainMediaItem.type) {&#10;                                MediaType.VIDEO -&gt; MEDIA_TYPE_VIDEO&#10;                                MediaType.AUDIO -&gt; MEDIA_TYPE_MUSIC&#10;                            }&#10;                        )&#10;                        .build()&#10;                )&#10;                .build()&#10;        }&#10;&#10;        exoPlayer.setMediaItems(exoMediaItems)&#10;        updatePlaybackState {&#10;            it.copy(&#10;                queue = mediaItems,&#10;                currentIndex = 0&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun addMediaItem(mediaItem: MediaItem) {&#10;        exoPlayer.addMediaItem(ExoMediaItem.fromUri(mediaItem.uri))&#10;    }&#10;&#10;    override fun removeMediaItem(index: Int) {&#10;        exoPlayer.removeMediaItem(index)&#10;    }&#10;&#10;    override fun prepare() {&#10;        exoPlayer.prepare()&#10;    }&#10;&#10;    override fun release() {&#10;        exoPlayer.removeListener(playerListener)&#10;        exoPlayer.release()&#10;        mediaSession.release()&#10;    }&#10;&#10;    override fun playMediaItem(mediaItem: MediaItem) {&#10;        setMediaItems(listOf(mediaItem))&#10;        prepare()&#10;        play()&#10;    }&#10;&#10;    override fun playMediaItems(mediaItems: List&lt;MediaItem&gt;, startIndex: Int) {&#10;        setMediaItems(mediaItems)&#10;        exoPlayer.seekTo(startIndex, 0L)&#10;        prepare()&#10;        play()&#10;    }&#10;&#10;    fun getPlayer(): ExoPlayer = exoPlayer&#10;&#10;    private fun updatePlaybackState(update: (PlaybackState) -&gt; PlaybackState) {&#10;        _playbackState.value = update(_playbackState.value)&#10;    }&#10;&#10;    private fun updateCurrentMediaItem() {&#10;        val currentMediaItem = exoPlayer.currentMediaItem&#10;        updatePlaybackState {&#10;            it.copy(&#10;                currentIndex = exoPlayer.currentMediaItemIndex,&#10;                playbackPosition = exoPlayer.currentPosition,&#10;                bufferedPosition = exoPlayer.bufferedPosition&#10;            )&#10;        }&#10;    }&#10;&#10;    // Mapper extension để fix lỗi 'toDomain'&#10;    private fun ExoMediaItem.toDomainModel(): MediaItem? {&#10;        // Giả định metadata chứa thông tin cần thiết; nếu không, fetch từ repository bằng ID&#10;        return MediaItem(&#10;            id = localConfiguration?.tag as? String ?: &quot;&quot;,  // Sử dụng tag để lưu ID domain nếu có&#10;            uri = localConfiguration?.uri.toString(),&#10;            displayName = mediaMetadata.displayTitle?.toString() ?: mediaMetadata.title?.toString() ?: &quot;Unknown&quot;,&#10;            title = mediaMetadata.title?.toString() ?: &quot;Unknown Title&quot;,&#10;            artist = mediaMetadata.artist?.toString() ?: &quot;Unknown Artist&quot;,&#10;            album = mediaMetadata.albumTitle?.toString() ?: &quot;Unknown Album&quot;,&#10;            duration = 0L,  // Lấy từ ExoPlayer nếu có, hoặc fetch&#10;            size = 0L,  // Fetch nếu cần&#10;            dateAdded = 0L,&#10;            dateModified = 0L,&#10;            mimeType = localConfiguration?.mimeType ?: &quot;&quot;,&#10;            albumArtUri = mediaMetadata.artworkUri?.toString(),&#10;            track = mediaMetadata.trackNumber,&#10;            year = mediaMetadata.recordingYear,&#10;            genre = mediaMetadata.genre.toString(),&#10;            bitrate = null,  // Không có trong metadata, fetch nếu cần&#10;            sampleRate = null,&#10;            type = if (mediaMetadata.mediaType == MEDIA_TYPE_VIDEO) MediaType.VIDEO else MediaType.AUDIO,&#10;            path = localConfiguration?.uri?.path ?: &quot;&quot;,&#10;            playCount = 0,&#10;            lastPlayed = null,&#10;            isFavorite = false,&#10;            isAvailable = true&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/playback/ExoPlayerManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/playback/ExoPlayerManager.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.playback&#10;&#10;import android.content.Context&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import androidx.media3.exoplayer.source.MediaSource&#10;import androidx.media3.exoplayer.source.ProgressiveMediaSource&#10;import androidx.media3.datasource.DefaultDataSource&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class ExoPlayerManager @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    private val _exoPlayer = ExoPlayer.Builder(context).build()&#10;    val exoPlayer: ExoPlayer = _exoPlayer&#10;    &#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying: StateFlow&lt;Boolean&gt; = _isPlaying.asStateFlow()&#10;    &#10;    private val _currentPosition = MutableStateFlow(0L)&#10;    val currentPosition: StateFlow&lt;Long&gt; = _currentPosition.asStateFlow()&#10;    &#10;    private val _duration = MutableStateFlow(0L)&#10;    val duration: StateFlow&lt;Long&gt; = _duration.asStateFlow()&#10;    &#10;    init {&#10;        _exoPlayer.addListener(object : Player.Listener {&#10;            override fun onIsPlayingChanged(isPlaying: Boolean) {&#10;                _isPlaying.value = isPlaying&#10;            }&#10;            &#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                if (playbackState == Player.STATE_READY) {&#10;                    _duration.value = _exoPlayer.duration&#10;                }&#10;            }&#10;        })&#10;        &#10;        // Update current position periodically&#10;        startPositionUpdates()&#10;    }&#10;    &#10;    fun playMedia(uri: String) {&#10;        val mediaItem = MediaItem.fromUri(uri)&#10;        val mediaSource = createMediaSource(mediaItem)&#10;        _exoPlayer.setMediaSource(mediaSource)&#10;        _exoPlayer.prepare()&#10;        _exoPlayer.play()&#10;    }&#10;    &#10;    fun pause() {&#10;        _exoPlayer.pause()&#10;    }&#10;    &#10;    fun resume() {&#10;        _exoPlayer.play()&#10;    }&#10;    &#10;    fun stop() {&#10;        _exoPlayer.stop()&#10;    }&#10;    &#10;    fun seekTo(position: Long) {&#10;        _exoPlayer.seekTo(position)&#10;    }&#10;    &#10;    fun skipToNext() {&#10;        if (_exoPlayer.hasNextMediaItem()) {&#10;            _exoPlayer.seekToNext()&#10;        }&#10;    }&#10;    &#10;    fun skipToPrevious() {&#10;        if (_exoPlayer.hasPreviousMediaItem()) {&#10;            _exoPlayer.seekToPrevious()&#10;        }&#10;    }&#10;    &#10;    fun setPlaylist(mediaItems: List&lt;MediaItem&gt;) {&#10;        _exoPlayer.setMediaItems(mediaItems)&#10;        _exoPlayer.prepare()&#10;    }&#10;    &#10;    fun release() {&#10;        _exoPlayer.release()&#10;    }&#10;    &#10;    private fun createMediaSource(mediaItem: MediaItem): MediaSource {&#10;        val dataSourceFactory = DefaultDataSource.Factory(context)&#10;        return ProgressiveMediaSource.Factory(dataSourceFactory)&#10;            .createMediaSource(mediaItem)&#10;    }&#10;    &#10;    private fun startPositionUpdates() {&#10;        // This would typically use a coroutine or timer to update position&#10;        // For simplicity, we'll use a basic approach&#10;        object : Runnable {&#10;            override fun run() {&#10;                if (_exoPlayer.isPlaying) {&#10;                    _currentPosition.value = _exoPlayer.currentPosition&#10;                }&#10;                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed(this, 1000)&#10;            }&#10;        }.run()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/playback/MediaNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/playback/MediaNotificationManager.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.playback&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.content.Context&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import androidx.media3.session.MediaSession&#10;import androidx.media3.session.MediaSessionService&#10;import com.tinhtx.player.common.Constants&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class MediaNotificationManager @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;    &#10;    init {&#10;        createNotificationChannel()&#10;    }&#10;    &#10;    fun showNotification(service: MediaSessionService, mediaSession: MediaSession) {&#10;        val notification = createNotification(mediaSession)&#10;        service.startForeground(Constants.NOTIFICATION_ID, notification)&#10;    }&#10;    &#10;    fun hideNotification() {&#10;        notificationManager.cancel(Constants.NOTIFICATION_ID)&#10;    }&#10;    &#10;    private fun createNotification(mediaSession: MediaSession): Notification {&#10;        return NotificationCompat.Builder(context, Constants.NOTIFICATION_CHANNEL_ID)&#10;            .setContentTitle(&quot;Now Playing&quot;)&#10;            .setContentText(&quot;Music Player&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_media_play)&#10;            .setOngoing(true)&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .build()&#10;    }&#10;    &#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                Constants.NOTIFICATION_CHANNEL_ID,&#10;                &quot;Media Playback&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Media playback controls&quot;&#10;                setShowBadge(false)&#10;            }&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/playback/PlaybackService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/playback/PlaybackService.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.playback&#10;&#10;import android.app.PendingIntent&#10;import android.content.Intent&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import androidx.media3.session.MediaSession&#10;import androidx.media3.session.MediaSessionService&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import javax.inject.Inject&#10;&#10;@AndroidEntryPoint&#10;class PlaybackService : MediaSessionService() {&#10;    &#10;    @Inject&#10;    lateinit var exoPlayer: ExoPlayer&#10;    &#10;    @Inject&#10;    lateinit var mediaNotificationManager: MediaNotificationManager&#10;    &#10;    private var mediaSession: MediaSession? = null&#10;    &#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        &#10;        val sessionActivityPendingIntent = packageManager?.getLaunchIntentForPackage(packageName)?.let { sessionIntent -&gt;&#10;            PendingIntent.getActivity(this, 0, sessionIntent, PendingIntent.FLAG_IMMUTABLE)&#10;        }&#10;        &#10;        mediaSession = MediaSession.Builder(this, exoPlayer)&#10;            .setSessionActivity(sessionActivityPendingIntent)&#10;            .build()&#10;            &#10;        exoPlayer.addListener(object : Player.Listener {&#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                when (playbackState) {&#10;                    Player.STATE_READY -&gt; {&#10;                        mediaNotificationManager.showNotification(this@PlaybackService, mediaSession!!)&#10;                    }&#10;                    Player.STATE_ENDED -&gt; {&#10;                        mediaNotificationManager.hideNotification()&#10;                    }&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    override fun onGetSession(controllerInfo: MediaSession.ControllerInfo): MediaSession? {&#10;        return mediaSession&#10;    }&#10;    &#10;    override fun onDestroy() {&#10;        mediaSession?.run {&#10;            player.release()&#10;            release()&#10;            mediaSession = null&#10;        }&#10;        mediaNotificationManager.hideNotification()&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/scanner/MediaStoreScanner.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/media/src/main/kotlin/com/tinhtx/player/scanner/MediaStoreScanner.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.scanner&#10;&#10;import android.content.ContentResolver&#10;import android.content.Context&#10;import android.database.Cursor&#10;import android.provider.MediaStore&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.model.MediaType&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class MediaStoreScanner @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    private val contentResolver: ContentResolver = context.contentResolver&#10;&#10;    suspend fun scanAudioFiles(): List&lt;MediaItem&gt; = withContext(Dispatchers.IO) {&#10;        val audioFiles = mutableListOf&lt;MediaItem&gt;()&#10;        &#10;        val projection = arrayOf(&#10;            MediaStore.Audio.Media._ID,&#10;            MediaStore.Audio.Media.TITLE,&#10;            MediaStore.Audio.Media.ARTIST,&#10;            MediaStore.Audio.Media.ALBUM,&#10;            MediaStore.Audio.Media.DURATION,&#10;            MediaStore.Audio.Media.DATA,&#10;            MediaStore.Audio.Media.SIZE,&#10;            MediaStore.Audio.Media.DATE_ADDED,&#10;            MediaStore.Audio.Media.MIME_TYPE&#10;        )&#10;        &#10;        val selection = &quot;${MediaStore.Audio.Media.IS_MUSIC} = 1&quot;&#10;        val sortOrder = &quot;${MediaStore.Audio.Media.TITLE} ASC&quot;&#10;        &#10;        contentResolver.query(&#10;            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,&#10;            projection,&#10;            selection,&#10;            null,&#10;            sortOrder&#10;        )?.use { cursor -&gt;&#10;            val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)&#10;            val titleColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)&#10;            val artistColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST)&#10;            val albumColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ALBUM)&#10;            val durationColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)&#10;            val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA)&#10;            val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.SIZE)&#10;            val dateAddedColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATE_ADDED)&#10;            val mimeTypeColumn = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE)&#10;            &#10;            while (cursor.moveToNext()) {&#10;                val id = cursor.getLong(idColumn).toString()&#10;                val title = cursor.getString(titleColumn) ?: &quot;Unknown&quot;&#10;                val artist = cursor.getString(artistColumn) ?: &quot;Unknown Artist&quot;&#10;                val album = cursor.getString(albumColumn) ?: &quot;Unknown Album&quot;&#10;                val duration = cursor.getLong(durationColumn)&#10;                val path = cursor.getString(dataColumn) ?: &quot;&quot;&#10;                val size = cursor.getLong(sizeColumn)&#10;                val dateAdded = cursor.getLong(dateAddedColumn) * 1000 // Convert to milliseconds&#10;                val mimeType = cursor.getString(mimeTypeColumn) ?: &quot;&quot;&#10;                &#10;                val uri = &quot;${MediaStore.Audio.Media.EXTERNAL_CONTENT_URI}/$id&quot;&#10;                &#10;                audioFiles.add(&#10;                    MediaItem(&#10;                        id = id,&#10;                        title = title,&#10;                        artist = artist,&#10;                        album = album,&#10;                        duration = duration,&#10;                        uri = uri,&#10;                        mediaType = MediaType.AUDIO,&#10;                        size = size,&#10;                        dateAdded = dateAdded,&#10;                        path = path,&#10;                        mimeType = mimeType&#10;                    )&#10;                )&#10;            }&#10;        }&#10;        &#10;        audioFiles&#10;    }&#10;&#10;    suspend fun scanVideoFiles(): List&lt;MediaItem&gt; = withContext(Dispatchers.IO) {&#10;        val videoFiles = mutableListOf&lt;MediaItem&gt;()&#10;        &#10;        val projection = arrayOf(&#10;            MediaStore.Video.Media._ID,&#10;            MediaStore.Video.Media.TITLE,&#10;            MediaStore.Video.Media.ARTIST,&#10;            MediaStore.Video.Media.ALBUM,&#10;            MediaStore.Video.Media.DURATION,&#10;            MediaStore.Video.Media.DATA,&#10;            MediaStore.Video.Media.SIZE,&#10;            MediaStore.Video.Media.DATE_ADDED,&#10;            MediaStore.Video.Media.MIME_TYPE&#10;        )&#10;        &#10;        val sortOrder = &quot;${MediaStore.Video.Media.TITLE} ASC&quot;&#10;        &#10;        contentResolver.query(&#10;            MediaStore.Video.Media.EXTERNAL_CONTENT_URI,&#10;            projection,&#10;            null,&#10;            null,&#10;            sortOrder&#10;        )?.use { cursor -&gt;&#10;            val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)&#10;            val titleColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.TITLE)&#10;            val artistColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.ARTIST)&#10;            val albumColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.ALBUM)&#10;            val durationColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)&#10;            val dataColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATA)&#10;            val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)&#10;            val dateAddedColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DATE_ADDED)&#10;            val mimeTypeColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.MIME_TYPE)&#10;            &#10;            while (cursor.moveToNext()) {&#10;                val id = cursor.getLong(idColumn).toString()&#10;                val title = cursor.getString(titleColumn) ?: &quot;Unknown&quot;&#10;                val artist = cursor.getString(artistColumn) ?: &quot;Unknown&quot;&#10;                val album = cursor.getString(albumColumn) ?: &quot;Unknown&quot;&#10;                val duration = cursor.getLong(durationColumn)&#10;                val path = cursor.getString(dataColumn) ?: &quot;&quot;&#10;                val size = cursor.getLong(sizeColumn)&#10;                val dateAdded = cursor.getLong(dateAddedColumn) * 1000&#10;                val mimeType = cursor.getString(mimeTypeColumn) ?: &quot;&quot;&#10;                &#10;                val uri = &quot;${MediaStore.Video.Media.EXTERNAL_CONTENT_URI}/$id&quot;&#10;                &#10;                videoFiles.add(&#10;                    MediaItem(&#10;                        id = id,&#10;                        title = title,&#10;                        artist = artist,&#10;                        album = album,&#10;                        duration = duration,&#10;                        uri = uri,&#10;                        mediaType = MediaType.VIDEO,&#10;                        size = size,&#10;                        dateAdded = dateAdded,&#10;                        path = path,&#10;                        mimeType = mimeType&#10;                    )&#10;                )&#10;            }&#10;        }&#10;        &#10;        videoFiles&#10;    }&#10;&#10;    suspend fun scanAllMediaFiles(): List&lt;MediaItem&gt; {&#10;        return scanAudioFiles() + scanVideoFiles()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/common/MediaItemCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/common/MediaItemCard.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.component.common&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import com.tinhtx.player.model.MediaItem&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MediaItemCard(&#10;    mediaItem: MediaItem,&#10;    onClick: (MediaItem) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        onClick = { onClick(mediaItem) },&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(80.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(12.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Album artwork&#10;            AsyncImage(&#10;                model = mediaItem.artworkUri,&#10;                contentDescription = &quot;Album artwork&quot;,&#10;                modifier = Modifier&#10;                    .size(56.dp)&#10;                    .clip(RoundedCornerShape(8.dp)),&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            &#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            &#10;            // Media info&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = mediaItem.title,&#10;                    style = MaterialTheme.typography.titleSmall,&#10;                    color = MaterialTheme.colorScheme.onSurface,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;                &#10;                Text(&#10;                    text = &quot;${mediaItem.artist} • ${mediaItem.album}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;            &#10;            // Duration&#10;            Text(&#10;                text = formatDuration(mediaItem.duration),&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatDuration(duration: Long): String {&#10;    val minutes = duration / 1000 / 60&#10;    val seconds = (duration / 1000) % 60&#10;    return String.format(&quot;%d:%02d&quot;, minutes, seconds)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/common/PermissionHandler.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/common/PermissionHandler.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.component.common&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import com.tinhtx.player.util.PermissionUtils&#10;&#10;@Composable&#10;fun PermissionHandler(&#10;    onPermissionsGranted: () -&gt; Unit,&#10;    onPermissionsDenied: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;    var showRationale by remember { mutableStateOf(false) }&#10;    &#10;    val permissionLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (allGranted) {&#10;            onPermissionsGranted()&#10;        } else {&#10;            showRationale = true&#10;            onPermissionsDenied()&#10;        }&#10;    }&#10;    &#10;    LaunchedEffect(Unit) {&#10;        if (PermissionUtils.hasRequiredPermissions(context)) {&#10;            onPermissionsGranted()&#10;        } else {&#10;            permissionLauncher.launch(PermissionUtils.REQUIRED_PERMISSIONS)&#10;        }&#10;    }&#10;    &#10;    if (showRationale) {&#10;        Card(&#10;            modifier = modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.errorContainer&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = &quot;Storage Permission Required&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                &#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                &#10;                Text(&#10;                    text = &quot;This app needs access to your device storage to play music and videos. Please grant the permission to continue.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                Button(&#10;                    onClick = {&#10;                        permissionLauncher.launch(PermissionUtils.REQUIRED_PERMISSIONS)&#10;                        showRationale = false&#10;                    },&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Text(&quot;Grant Permission&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/common/SearchBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/common/SearchBar.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.component.common&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SearchBar(&#10;    query: String,&#10;    onQueryChange: (String) -&gt; Unit,&#10;    onSearch: (String) -&gt; Unit,&#10;    placeholder: String = &quot;Search music...&quot;,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    &#10;    OutlinedTextField(&#10;        value = query,&#10;        onValueChange = onQueryChange,&#10;        placeholder = {&#10;            Text(&#10;                text = placeholder,&#10;                style = MaterialTheme.typography.bodyMedium&#10;            )&#10;        },&#10;        leadingIcon = {&#10;            Icon(&#10;                imageVector = Icons.Default.Search,&#10;                contentDescription = &quot;Search&quot;,&#10;                tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;        },&#10;        trailingIcon = {&#10;            if (query.isNotEmpty()) {&#10;                IconButton(&#10;                    onClick = { onQueryChange(&quot;&quot;) }&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Clear,&#10;                        contentDescription = &quot;Clear&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                    )&#10;                }&#10;            }&#10;        },&#10;        keyboardOptions = KeyboardOptions(&#10;            imeAction = ImeAction.Search&#10;        ),&#10;        keyboardActions = KeyboardActions(&#10;            onSearch = {&#10;                onSearch(query)&#10;                keyboardController?.hide()&#10;            }&#10;        ),&#10;        singleLine = true,&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp),&#10;        colors = OutlinedTextFieldDefaults.colors(&#10;            focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;            unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.5f)&#10;        )&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/media/EqualizerComponents.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/component/media/EqualizerComponents.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.component.media&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.unit.dp&#10;&#10;@Composable&#10;fun EqualizerComponents(&#10;    bassBoostLevel: Int,&#10;    virtualizerLevel: Int,&#10;    onBassBoostChange: (Int) -&gt; Unit,&#10;    onVirtualizerChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Audio Effects&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            &#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            &#10;            // Bass Boost&#10;            Column {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Bass Boost&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Text(&#10;                        text = &quot;$bassBoostLevel%&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;                &#10;                Slider(&#10;                    value = bassBoostLevel.toFloat(),&#10;                    onValueChange = { onBassBoostChange(it.toInt()) },&#10;                    valueRange = 0f..100f,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = SliderDefaults.colors(&#10;                        thumbColor = MaterialTheme.colorScheme.primary,&#10;                        activeTrackColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                )&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            &#10;            // Virtualizer&#10;            Column {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Virtualizer&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Text(&#10;                        text = &quot;$virtualizerLevel%&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;                &#10;                Slider(&#10;                    value = virtualizerLevel.toFloat(),&#10;                    onValueChange = { onVirtualizerChange(it.toInt()) },&#10;                    valueRange = 0f..100f,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    colors = SliderDefaults.colors(&#10;                        thumbColor = MaterialTheme.colorScheme.primary,&#10;                        activeTrackColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/main/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/main/HomeScreen.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.screen.main&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.component.common.MediaItemCard&#10;import com.tinhtx.player.component.common.PermissionHandler&#10;import com.tinhtx.player.model.MediaItem&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HomeScreen(&#10;    onNavigateToPlayer: (MediaItem) -&gt; Unit,&#10;    onNavigateToSearch: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: HomeViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    var permissionsGranted by remember { mutableStateOf(false) }&#10;    &#10;    Column(modifier = modifier.fillMaxSize()) {&#10;        // Top App Bar&#10;        TopAppBar(&#10;            title = {&#10;                Text(&#10;                    text = &quot;TinhTX Player&quot;,&#10;                    style = MaterialTheme.typography.titleLarge&#10;                )&#10;            },&#10;            actions = {&#10;                IconButton(onClick = onNavigateToSearch) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Search,&#10;                        contentDescription = &quot;Search&quot;&#10;                    )&#10;                }&#10;            },&#10;            colors = TopAppBarDefaults.topAppBarColors(&#10;                containerColor = MaterialTheme.colorScheme.primary,&#10;                titleContentColor = MaterialTheme.colorScheme.onPrimary,&#10;                actionIconContentColor = MaterialTheme.colorScheme.onPrimary&#10;            )&#10;        )&#10;        &#10;        if (!permissionsGranted) {&#10;            PermissionHandler(&#10;                onPermissionsGranted = {&#10;                    permissionsGranted = true&#10;                    viewModel.loadMediaItems()&#10;                },&#10;                onPermissionsDenied = {&#10;                    // Handle permission denied&#10;                }&#10;            )&#10;        } else {&#10;            when (uiState) {&#10;                is HomeUiState.Loading -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;                &#10;                is HomeUiState.Success -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentPadding = PaddingValues(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        items(uiState.mediaItems) { mediaItem -&gt;&#10;                            MediaItemCard(&#10;                                mediaItem = mediaItem,&#10;                                onClick = onNavigateToPlayer&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                is HomeUiState.Error -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = uiState.message,&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            color = MaterialTheme.colorScheme.error&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/main/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/main/HomeViewModel.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.screen.main&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.tinhtx.player.common.Resource&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.usecase.GetMediaItemsUseCase&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val getMediaItemsUseCase: GetMediaItemsUseCase&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow&lt;HomeUiState&gt;(HomeUiState.Loading)&#10;    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadMediaItems() {&#10;        viewModelScope.launch {&#10;            getMediaItemsUseCase.getAllMediaItems().collect { resource -&gt;&#10;                _uiState.value = when (resource) {&#10;                    is Resource.Loading -&gt; HomeUiState.Loading&#10;                    is Resource.Success -&gt; {&#10;                        val mediaItems = resource.data ?: emptyList()&#10;                        HomeUiState.Success(mediaItems)&#10;                    }&#10;                    is Resource.Error -&gt; HomeUiState.Error(&#10;                        resource.message ?: &quot;Unknown error occurred&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshMediaItems() {&#10;        viewModelScope.launch {&#10;            getMediaItemsUseCase.refreshMediaLibrary()&#10;            loadMediaItems()&#10;        }&#10;    }&#10;}&#10;&#10;sealed class HomeUiState {&#10;    object Loading : HomeUiState()&#10;    data class Success(val mediaItems: List&lt;MediaItem&gt;) : HomeUiState()&#10;    data class Error(val message: String) : HomeUiState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/MusicPlayerScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/MusicPlayerScreen.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.screen.player&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import coil.compose.AsyncImage&#10;import com.tinhtx.player.common.formatDuration&#10;&#10;@Composable&#10;fun MusicPlayerScreen(&#10;    mediaId: String,&#10;    onNavigateBack: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: MusicPlayerViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    &#10;    LaunchedEffect(mediaId) {&#10;        viewModel.loadMedia(mediaId)&#10;    }&#10;    &#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        // Back button&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.Start&#10;        ) {&#10;            IconButton(onClick = onNavigateBack) {&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        &#10;        // Album artwork&#10;        AsyncImage(&#10;            model = uiState.currentMedia?.artworkUri,&#10;            contentDescription = &quot;Album artwork&quot;,&#10;            modifier = Modifier&#10;                .size(300.dp)&#10;                .clip(RoundedCornerShape(16.dp)),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;        &#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        &#10;        // Song info&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = uiState.currentMedia?.title ?: &quot;&quot;,&#10;                style = MaterialTheme.typography.titleLarge,&#10;                textAlign = TextAlign.Center,&#10;                maxLines = 2,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;            &#10;            Text(&#10;                text = uiState.currentMedia?.artist ?: &quot;&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                textAlign = TextAlign.Center,&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        &#10;        // Progress bar&#10;        Column {&#10;            Slider(&#10;                value = uiState.currentPosition.toFloat(),&#10;                onValueChange = { viewModel.seekTo(it.toLong()) },&#10;                valueRange = 0f..(uiState.currentMedia?.duration?.toFloat() ?: 0f),&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;            &#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = uiState.currentPosition.formatDuration(),&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;                Text(&#10;                    text = (uiState.currentMedia?.duration ?: 0L).formatDuration(),&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.height(32.dp))&#10;        &#10;        // Control buttons&#10;        Row(&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = { viewModel.skipToPrevious() }) {&#10;                Icon(&#10;                    imageVector = Icons.Default.SkipPrevious,&#10;                    contentDescription = &quot;Previous&quot;,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;            }&#10;            &#10;            FloatingActionButton(&#10;                onClick = { viewModel.togglePlayPause() },&#10;                modifier = Modifier.size(64.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = if (uiState.isPlaying) Icons.Default.Pause else Icons.Default.PlayArrow,&#10;                    contentDescription = if (uiState.isPlaying) &quot;Pause&quot; else &quot;Play&quot;,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;            }&#10;            &#10;            IconButton(onClick = { viewModel.skipToNext() }) {&#10;                Icon(&#10;                    imageVector = Icons.Default.SkipNext,&#10;                    contentDescription = &quot;Next&quot;,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/MusicPlayerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/MusicPlayerViewModel.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.screen.player&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.usecase.GetMediaItemsUseCase&#10;import com.tinhtx.player.usecase.PlayMediaUseCase&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class MusicPlayerViewModel @Inject constructor(&#10;    private val getMediaItemsUseCase: GetMediaItemsUseCase,&#10;    private val playMediaUseCase: PlayMediaUseCase&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(MusicPlayerUiState())&#10;    val uiState: StateFlow&lt;MusicPlayerUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadMedia(mediaId: String) {&#10;        viewModelScope.launch {&#10;            getMediaItemsUseCase.getMediaItemById(mediaId).collect { resource -&gt;&#10;                resource.data?.let { mediaItem -&gt;&#10;                    _uiState.value = _uiState.value.copy(currentMedia = mediaItem)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun togglePlayPause() {&#10;        viewModelScope.launch {&#10;            val currentMedia = _uiState.value.currentMedia ?: return@launch&#10;            &#10;            if (_uiState.value.isPlaying) {&#10;                playMediaUseCase.pauseMedia()&#10;                _uiState.value = _uiState.value.copy(isPlaying = false)&#10;            } else {&#10;                playMediaUseCase.playMedia(currentMedia)&#10;                _uiState.value = _uiState.value.copy(isPlaying = true)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun seekTo(position: Long) {&#10;        viewModelScope.launch {&#10;            playMediaUseCase.seekTo(position)&#10;            _uiState.value = _uiState.value.copy(currentPosition = position)&#10;        }&#10;    }&#10;&#10;    fun skipToNext() {&#10;        viewModelScope.launch {&#10;            playMediaUseCase.skipToNext()&#10;        }&#10;    }&#10;&#10;    fun skipToPrevious() {&#10;        viewModelScope.launch {&#10;            playMediaUseCase.skipToPrevious()&#10;        }&#10;    }&#10;}&#10;&#10;data class MusicPlayerUiState(&#10;    val currentMedia: MediaItem? = null,&#10;    val isPlaying: Boolean = false,&#10;    val currentPosition: Long = 0L,&#10;    val bufferedPosition: Long = 0L&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/VideoPlayerScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/VideoPlayerScreen.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.screen.player&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.media3.ui.PlayerView&#10;&#10;@Composable&#10;fun VideoPlayerScreen(&#10;    mediaId: String,&#10;    onNavigateBack: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    viewModel: VideoPlayerViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val configuration = LocalConfiguration.current&#10;    val isLandscape = configuration.orientation == android.content.res.Configuration.ORIENTATION_LANDSCAPE&#10;    &#10;    LaunchedEffect(mediaId) {&#10;        viewModel.loadVideo(mediaId)&#10;    }&#10;    &#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .background(Color.Black)&#10;    ) {&#10;        // Video player view&#10;        AndroidView(&#10;            factory = { context -&gt;&#10;                PlayerView(context).apply {&#10;                    useController = !isLandscape&#10;                    player = viewModel.exoPlayer&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize()&#10;        )&#10;        &#10;        // Custom controls overlay (only in landscape)&#10;        if (isLandscape) {&#10;            VideoControls(&#10;                isPlaying = uiState.isPlaying,&#10;                currentPosition = uiState.currentPosition,&#10;                duration = uiState.currentVideo?.duration ?: 0L,&#10;                onPlayPause = { viewModel.togglePlayPause() },&#10;                onSeek = { viewModel.seekTo(it) },&#10;                onBack = onNavigateBack,&#10;                modifier = Modifier.align(Alignment.BottomCenter)&#10;            )&#10;        } else {&#10;            // Portrait mode back button&#10;            IconButton(&#10;                onClick = onNavigateBack,&#10;                modifier = Modifier&#10;                    .align(Alignment.TopStart)&#10;                    .padding(16.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;,&#10;                    tint = Color.White&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun VideoControls(&#10;    isPlaying: Boolean,&#10;    currentPosition: Long,&#10;    duration: Long,&#10;    onPlayPause: () -&gt; Unit,&#10;    onSeek: (Long) -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .background(Color.Black.copy(alpha = 0.7f))&#10;            .padding(16.dp)&#10;    ) {&#10;        // Progress bar&#10;        Slider(&#10;            value = currentPosition.toFloat(),&#10;            onValueChange = { onSeek(it.toLong()) },&#10;            valueRange = 0f..duration.toFloat(),&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = SliderDefaults.colors(&#10;                thumbColor = Color.White,&#10;                activeTrackColor = Color.White&#10;            )&#10;        )&#10;        &#10;        // Control buttons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(onClick = onBack) {&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;Back&quot;,&#10;                    tint = Color.White&#10;                )&#10;            }&#10;            &#10;            IconButton(onClick = onPlayPause) {&#10;                Icon(&#10;                    imageVector = if (isPlaying) Icons.Default.Pause else Icons.Default.PlayArrow,&#10;                    contentDescription = if (isPlaying) &quot;Pause&quot; else &quot;Play&quot;,&#10;                    tint = Color.White,&#10;                    modifier = Modifier.size(32.dp)&#10;                )&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.width(48.dp)) // Balance the layout&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/VideoPlayerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/screen/player/VideoPlayerViewModel.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.screen.player&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.tinhtx.player.model.MediaItem&#10;import com.tinhtx.player.usecase.GetMediaItemsUseCase&#10;import com.tinhtx.player.usecase.PlayMediaUseCase&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class VideoPlayerViewModel @Inject constructor(&#10;    private val getMediaItemsUseCase: GetMediaItemsUseCase,&#10;    private val playMediaUseCase: PlayMediaUseCase,&#10;    val exoPlayer: ExoPlayer&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(VideoPlayerUiState())&#10;    val uiState: StateFlow&lt;VideoPlayerUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun loadVideo(mediaId: String) {&#10;        viewModelScope.launch {&#10;            getMediaItemsUseCase.getMediaItemById(mediaId).collect { resource -&gt;&#10;                resource.data?.let { mediaItem -&gt;&#10;                    _uiState.value = _uiState.value.copy(currentVideo = mediaItem)&#10;                    // Load video into ExoPlayer&#10;                    playMediaUseCase.playMedia(mediaItem)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun togglePlayPause() {&#10;        viewModelScope.launch {&#10;            if (_uiState.value.isPlaying) {&#10;                playMediaUseCase.pauseMedia()&#10;                _uiState.value = _uiState.value.copy(isPlaying = false)&#10;            } else {&#10;                val currentVideo = _uiState.value.currentVideo ?: return@launch&#10;                playMediaUseCase.playMedia(currentVideo)&#10;                _uiState.value = _uiState.value.copy(isPlaying = true)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun seekTo(position: Long) {&#10;        viewModelScope.launch {&#10;            playMediaUseCase.seekTo(position)&#10;            _uiState.value = _uiState.value.copy(currentPosition = position)&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        exoPlayer.release()&#10;    }&#10;}&#10;&#10;data class VideoPlayerUiState(&#10;    val currentVideo: MediaItem? = null,&#10;    val isPlaying: Boolean = false,&#10;    val currentPosition: Long = 0L,&#10;    val bufferedPosition: Long = 0L&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Color.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Color.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;val Purple80 = Color(0xFFD0BCFF)&#10;val PurpleGrey80 = Color(0xFFCCC2DC)&#10;val Pink80 = Color(0xFFEFB8C8)&#10;&#10;val Purple40 = Color(0xFF6650a4)&#10;val PurpleGrey40 = Color(0xFF625b71)&#10;val Pink40 = Color(0xFF7D5260)&#10;&#10;// Custom colors for music player&#10;val PlayerPrimary = Color(0xFF1DB954)&#10;val PlayerSecondary = Color(0xFF1ED760)&#10;val PlayerBackground = Color(0xFF121212)&#10;val PlayerSurface = Color(0xFF181818)&#10;val PlayerOnSurface = Color(0xFFFFFFFF)&#10;val PlayerAccent = Color(0xFFFF6B35)&#10;&#10;// Dark theme colors&#10;val DarkPrimary = Color(0xFF1DB954)&#10;val DarkOnPrimary = Color(0xFF000000)&#10;val DarkSecondary = Color(0xFF1ED760)&#10;val DarkBackground = Color(0xFF121212)&#10;val DarkSurface = Color(0xFF181818)&#10;val DarkOnSurface = Color(0xFFFFFFFF)&#10;&#10;// Light theme colors&#10;val LightPrimary = Color(0xFF1DB954)&#10;val LightOnPrimary = Color(0xFFFFFFFF)&#10;val LightSecondary = Color(0xFF1ED760)&#10;val LightBackground = Color(0xFFFFFFFF)&#10;val LightSurface = Color(0xFFF5F5F5)&#10;val LightOnSurface = Color(0xFF000000)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Shape.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Shape.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.theme&#10;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Shapes&#10;import androidx.compose.ui.unit.dp&#10;&#10;val Shapes = Shapes(&#10;    small = RoundedCornerShape(4.dp),&#10;    medium = RoundedCornerShape(8.dp),&#10;    large = RoundedCornerShape(16.dp),&#10;    extraLarge = RoundedCornerShape(24.dp)&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Theme.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.theme&#10;&#10;import android.app.Activity&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.SideEffect&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.core.view.WindowCompat&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = DarkPrimary,&#10;    onPrimary = DarkOnPrimary,&#10;    secondary = DarkSecondary,&#10;    background = DarkBackground,&#10;    surface = DarkSurface,&#10;    onSurface = DarkOnSurface&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = LightPrimary,&#10;    onPrimary = LightOnPrimary,&#10;    secondary = LightSecondary,&#10;    background = LightBackground,&#10;    surface = LightSurface,&#10;    onSurface = LightOnSurface&#10;)&#10;&#10;@Composable&#10;fun TinhTXPlayerTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;    &#10;    val view = LocalView.current&#10;    if (!view.isInEditMode) {&#10;        SideEffect {&#10;            val window = (view.context as Activity).window&#10;            window.statusBarColor = colorScheme.primary.toArgb()&#10;            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme&#10;        }&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        shapes = Shapes,&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Type.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/presentation/src/main/kotlin/com/tinhtx/player/theme/Type.kt" />
              <option name="updatedContent" value="package com.tinhtx.player.theme&#10;&#10;import androidx.compose.material3.Typography&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.sp&#10;&#10;// Set of Material typography styles to start with&#10;val Typography = Typography(&#10;    bodyLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Normal,&#10;        fontSize = 16.sp,&#10;        lineHeight = 24.sp,&#10;        letterSpacing = 0.5.sp&#10;    ),&#10;    titleLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Bold,&#10;        fontSize = 22.sp,&#10;        lineHeight = 28.sp,&#10;        letterSpacing = 0.sp&#10;    ),&#10;    titleMedium = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.SemiBold,&#10;        fontSize = 18.sp,&#10;        lineHeight = 24.sp,&#10;        letterSpacing = 0.sp&#10;    ),&#10;    titleSmall = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Medium,&#10;        fontSize = 16.sp,&#10;        lineHeight = 20.sp,&#10;        letterSpacing = 0.1.sp&#10;    ),&#10;    bodyMedium = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Normal,&#10;        fontSize = 14.sp,&#10;        lineHeight = 20.sp,&#10;        letterSpacing = 0.25.sp&#10;    ),&#10;    bodySmall = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Normal,&#10;        fontSize = 12.sp,&#10;        lineHeight = 16.sp,&#10;        letterSpacing = 0.4.sp&#10;    ),&#10;    labelLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Medium,&#10;        fontSize = 14.sp,&#10;        lineHeight = 20.sp,&#10;        letterSpacing = 0.1.sp&#10;    )&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>